## Clean Code

### 02. 의미 있는 이름

- **의도를 분명히 밝혀라**

  - 의도가 분명한 이름은 매우 중요
  - 좋은 이름을 짓는 시간보다 좋은 이름으로 절약하는 시간이 훨씬 많음
  - 변수, 함수, 클래스 이름은 존재 이유, 수행 기능, 사용 방법을 함축해야함

  ```ts
  // bad
  const d;
  
  function getThem() {
    const list1 = [];
   
    for (const x of theList) {
      if (x[0] === 4) {
        list1.push(x);
      }
    }
    return list1;
  }
  
  // good
  const daySinceCreation;
  
  function getFlaggedCells() {
    const flaggedCells = [];
    for (const cell of gameBoard) {
      if (cell[STATUS_VALUE] === FLAGGED) {
        flaggedCells.push(cell);
      }
    }
    return flaggedCells;
  }
  ```

- 그릇된 정보를 피하라

  - 그릇된 단서를 남기면 코드의 의미를 흐릴 수 있음
  - 흡사한 이름 사용 x
  - 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용 x
  - 유사한 개념은 유사한 표기법 사용
  - 소문자 l, 대문자 O 사용 x

  ```ts
  // bad
  const accountList = { account1: 'john', account2: 'Tom' };
  
  // good
  const accountGroup = { account1: 'john', account2: 'Tom' };
  ```



- **의미 있게 구분하라**

  - 컴파일러나 인터프리터만 통과하려는 코드는 문제를 일으킴

  - 연속된 숫자를 덧붙이기 x
    - a1, a2, a3, ...
    
  - 불용어를 추가한 이름 x
    - productInfo = productData
    - moneyAmount = money
    - theMessage = message
    - accountData = account
    
    

- **발음하기 쉬운 이름을 사용하라**

  - 발음하기 어려운 이름은 토론하기도 어려움

  ```ts
  // bad
  const DtcRcrd102 = {
    genymdhms: new Date(),
    modymdhms: new Date(),
    pszqint = "102"
  };
  
  // good
  const Customer = {
    generationTimestamp: new Date(),
    modificationTimestamp: new Date(),
    recodId: "102"
  };
  ```



- **검색하기 쉬운 이름을 사용하라**

  - 이름 길이는 범위 크기에 비례해야 함 (간단한 메서드에서 로컬 변수만 한 문자를 사용)

  ```ts
  // bad
  for (let i = 0; i < 34; i++) {
    let s = 0;
    s += (t[j]*4/5);
  }
  
  // good
  const realDaysPerIdealDay = 4; 
  const NUMBER_OF_TASKS = 34;
  const WORK_DAYS_PER_WEEK = 5;
  let sum = 0;
  for (let i=0; i < NUMBER_OF_TASKS; i++) {
    realTaskDays = taskEstimate[i] * realDaysPerIdealDay;
    realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK);
    sum += realTaskWeeks;
  }
  ```



- **인코딩을 피하라**

  - 헝가리식 표기법 x
  - 멤버 변수 접두어 x
  - 인터페이스 클래스와 구현 클래스에서는 인코딩이 필요할 수도 있음

  

- **자신의 기억력을 자랑하지 마라**

  - 독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 변수 이름은 바람직하지 못함
  - 루프에서 반복 횟수를 세는 변수 i, j, k는 괜찮음

  

- **클래스 이름**

  - 명사나 명사구가 적합
    - Good: Customer, WikiPage, AddressParser
    - Bad: Manager, Processor, Data, Info / 동사
    
    

- **메서드 이름**

  - 동사나 동사구가 적합
    - postPayment, deletePage, save
  - 접근자, 변경자, 조건자 -> get, set, is (javabean 기준)

  

- **기발한 이름은 피하라**

  - 재미난 이름보다 명료한 이름
  - 의도를 분명하고 솔직하게 표현하기

  

- **한 개념에 한 단어를 사용하라**

  - 추상적인 개념 하나에 단어 하나를 선택해 이를 고수하기
    - 똑같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스러움
  - 일관성 있는 어휘를 사용할 것

  

- **말장난을 하지 마라**

  - 한 단어를 두 가지 목적으로 사용하지 말 것

  - 다른 개념에 같은 단어를 사용한다면 말장난에 불과

    - number나 string을 더하는 add 함수
    - 집합에 값하나를 추가하는 함수 ? add가 아닌 insert나 append 사용

    

- **해법 영역에서 가져온 이름을 사용하라**

  - 코드를 읽을 사람도 프로그래머
  - 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮음
  - 기술 개념에는 기술 이름이 가장 적합한 선택

  

- **문제 영역에서 가져온 이름을 사용하라**

  - 적절한 프로그래머 용어가 없다면 문제 영역에서 이름을 가져오기
  - 우수한 프로그래머와 설계자라면 해법 영역과 문제 영역을 구분할 줄 알아야 함

  

- **의미 있는 맥락을 추가하라**

  - 이름은 클래스, 함수, 이름 공간에 넣어 맥락을 부여하고, 모든 방법이 실패하면 마지막 수단으로 접두어를 붙임
    - firstName, street, city, stage -> addressFirstName, addressStreet, addressCity, addressStage

  ```ts
  // bad
  function printGuessStatistics(candidate, count) {
    let number = '';
    let verb = '';
    let pluralModifier = '';
    if (count === 0) {
      number = 'no';
      verb = 'are';
      pluralModifier = 's';
    } else if (count === 1) {
      number = '1';
      verb = 'is';
      pluralModifier = '';
    } else {
      number = String(count);
      verb = 'are';
      pluralModifier = 's';
    }
    const guessMessage = `There ${verb} ${number} ${candidate} ${pluralModifier}`;
    console.log(guessMessage);
  }
  
  // good
  const GuessStatisticsMessage = (candidateValue, countValue) => {
    const candidate = candidateValue;
    const count = countValue;
    let number = '';
    let verb = '';
    let pluralModifier = '';
    
    return function make() {
      createPluralDependentMessageParts(count);
      return `There ${verb} ${number} ${candidate} ${pluralModifier}`;
    }
    
    function createPluralDependentMessageParts() {
      if (count === 0) {
        thereAreaNoLetters();
      } else if (count === 1) {
        thereIsOneLetter();
      } else {
        thereAreManyLetters();
      }
    }
    
    function thereAreManyLetters() {
      number = String(count);
      verb = 'are';
      pluralModifier = 's';
    }
    
    function thereIsOneLetter() {
      number = '1';
      verb = 'is';
      pluralModifier = '';
    }
    
    function thereAreNoLetters() {
      number = 'no';
      verb = 'are';
      pluralModifier = 's';
    }
  }
  ```

  

- **불필요한 맥락을 없애라**

  - 일반적으로 짧은 이름이 긴 이름보다 좋음 (단, 의미가 분명한 경우에 한해서)
  - 이름에 불필요한 맥락을 추가하지 않도록 주의
    - accountAddress와 customerAddress는 Address 클래스 인스턴스로는 좋은 이름이나 클래스 이름으로는 적합하지 못함
    - 클래스 이름으로는 Address가 적합



### 03. 함수

- **작게 만들어라**

  - `if / else / while` 문 등에 들어가는 블록은 한 줄이어야 한다

    - 대게 거기서 함수를 호출
    - 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기 쉬워짐

  - 중첩 구조가 생길수록 함수가 커져서는 안됨

    - 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 됨

    

- **한 가지만 해라**

  - ***함수는 한 가지를 해야 한다. 그 한 가지를 잘해야 한다. 그 한 가지만을 해야 한다.***
  - 지정된 함수 이름 아래에서 추상화 수준이 하나여야 함
  - 함수가 '한 가지'만 하는지 판단하는 방법
    - 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈



- **함수 당 추상화 수준은 하나로!**
  - 함수가 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 함
  - 위애서 아래로 코드 읽기: **내려가기** 규칙
    - 코드는 위에서 아래로 이야기처럼 읽혀야 좋음
    - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 옴



- **Switch** 문
  - switch 문은 N가지를 처리함
  - 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않도록 설계(?) -> 다형성 이용



- **서술적인 이름을 사용하라!**
  - 함수가 하는 일을 잘 표현할 수 있는 이름
  - 길고 서술적인 이름이 짧고 어려운 이름보다 좋음
  - 이름을 붙일 때는 일관성이 있어야 함



- **함수 인수**
	- 함수에서 이상적인 인수 개수는 0개
	- 3개 이상의 인수는 피하는 편이 좋음
	- 인수는 개념을 이해하기 어렵게 만듬
	- 인수가 많으면 테스트 케이스를 작성하기도 어려움
	- 플래그 인수
  		- 함수로 boolean 형태를 넘기기 X
  		- 함수가 한꺼번에 여러가지를 처리한다고 대놓고 공표하는 셈
  		- 함수를 나눠야 좋음 (좋아요 같은 거는...? 과연 나누는게 좋은 방법론인가...?)
	- 인수가 많다면 독자적인 클래스 변수(혹은 객체)로 선언할 가능성을 짚어보자
	- 동사와 키워드
  		- 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수
  		- 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 함 : `writeField(name)`
  		- 함수 이름에 키워드를 추가하는 방법 : `assertExpectedEqualsActual(expected, actual)` -> 인수 순서를 기억할 필요가 없어짐




- **부수 효과를 일으키지 마라!**
  - 함수에서 한 가지를 하겠다고 약속하고 남몰래 다른 짓을 한다
  - 예상치 못하게 클래스 변수를 수정하거나, 함수로 넘어온 인수나 시스템 전역 변수를 수정함
  - 출력 인수를 피해야 함

- **명령과 조회를 분리하라!**
	-  함수는 객체 정보를 반환하거나 객체 상태를 변경하거나 둘 중 하나여야 함
	-  즉, 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 함
	-  둘 다 한다면 혼란을 초래할 수 있음

- **오류 코드보다 예외를 사용하라!**
	- 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반함
	- 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해짐
	- try/catch 블록은 별도 함수로 뽑아내는 편이 좋음 -> 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞음
	- 오류 처리도 '한 가지' 작업만 해야 함

- **반복하지 마라!**
	- 중복은 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 여러 곳을 손봐야 함
	- 오류가 발생할 가능성도 높음

- **구조적 프로그래밍**
	- 구조적 프로그래밍 원칙 -> 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 함
	- 즉, 함수는 return 문이 하나여야 함 (break, continue, goto 사용 X)
	- 함수가 작다면 구조적 프로그래밍은 별 이익을 제공하지 못함
	
- **함수를 어떻게 짜죠?**
	- 소프트웨어를 짜는 행위는 여느 글짓기와 비슷함 
	- 처음에는 길고 복잡하고, 들여쓰기 단계도 많고 중복된 루트도 많음
	- 임수 목록도 아주 길고, 이름도 즉흥적이며 코드는 중복됨
	- 그 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스를 만듬
	- 그 후 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거
	- 메서드를 줄이고 순서를 바꾸며 전체 클래스를 쪼갬
	- 코드는 항상 단위 테스트를 통과해야 함



## 04. 주석

- 개요
  - 코드로 의도를 표현하지 못해, 실패를 만회하기 위해 주석을 사용
  - 주석은 오래될수록 코드와 멀어지며 완전히 그릇될 가능성도 커짐
  - 코드는 변화하고 진화하지만, 주석을 유지하고 보수하진 않는다
  - 부정확한 주석은 아예 없는 주석보다 훨씬 더 나쁘다
  - 코드만이 정확한 정보를 제공하는 유일한 출처이므로 주석을 가능한 줄여야한다



- 주석은 나쁜 코드를 보완하지 못한다
  - 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문
  - 나쁜 코드를 주석으로 설명하려하지 말고 코드를 정리하자!



- 코드로 의도를 표현하라!
  - 코드로 대다수 의도를 표현할 수 있다
  - 많은 경우 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다



- 좋은 주석
  - 정말로 좋은 주석은, 주석을 달지 않을 방법을 찾아낸 주석이다!
  - 법적인 주석
    - 각 소스 첫머리에 들어가는 저작권 정보와 소유권 정보
  - 정보를 제공하는 주석
    - 때로는 기본적인 정보를 주석으로 제공하면 편리함
    - But, 웬만하면 코드로 대체 가능
  - 의도를 설명하는 주석
    - 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명
  - 의미를 명료하게 밝히는 주석
    - 일반적으로 인수나 반환값 자체를 명확하게 만들면 더 좋음
    - 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용
  - 결과를 경고하는 주석
    - 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용
  - TODO 주석
    - '앞으로 할 일'을 //TODO 주석으로 남겨두면 편함
    - TODO 주석은 프로그래머가 필요하다 여기지만 당장 구현하기 어려운 업무를 기술
    - 주기적으로 TODO 주석을 점검해 없애도 괜찮은 주석은 없애라고 권함
  - 중요성을 강조하는 주석
    - 자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조하기 위해 주석을 사용



- 나쁜 주석
  - 대다수의 주석이 이 범주에 속함
  - 주절거리는 주석
    - 특별한 이유 없이 의무감으로 혹은 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비
    - 주석을 달기로 결정했다면 충분한 시간을 들여 최선의 주석을 달도록 노력
  - 같은 이야기를 중복하는 주석
    - 코드 내용과 같은 주석
    - 자칫하면 코드보다 주석을 읽는 시간이 더 오래 걸림
  - 오해할 여지가 있는 주석
    - 의도는 좋았으나 프로그래머가 딱 맞을 정도로 엄밀하게는 주석을 달지 못하는 경우도 있음
    - 주석에 담긴 '살짝 잘못된 정보'로 인해 잘못된 코드가 작성될 수 있음
  - 의무적으로 다는 주석
    - 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래함
  - 있으나 마나 한 주석
    - 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석
  - 위치를 표시하는 주석
    - 소스 파일에서 특정 위치를 표시하려 주석을 사용
    - 너무 자주 사용하지 않으면 배너는 눈에 띄며 주위를 환기시킬 수도 있음
    - 반드시 필요할 때만, 아주 드물게 사용하는 편이 좋음
  - 닫는 괄호에 다는 주석
    - 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만 작고 캡슐화 된 함수에는 좋지 않음
    - 주석 대신 함수를 줄이려고 시도하자
  - 공로를 돌리거나 저자를 표시하는 주석
    - 소스 코드 관리 시스템이 다 기억해준다
  - 주석으로 처리한 코드
    - 주석으로 처리된 코드는 다름 사람이 지우기를 주저함
    - 소스 코드 관리 시스템이 다 기억해준다
  - 전역 정보
    - 주석을 달아야 한다면 근처에 있는 코드만 기술하라
    - 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라
  - 너무 많은 정보
    - 주석에다 흥미로운 역사나 관련없는 정보를 장황하게 늘어놓지 마라
  - 모호한 관계
    - 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 함
    - 이왕 공들여 주석을 달았다면 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알 수 있어야 한다
  - 함수 헤더
    - 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다





## 05. 형식 맞추기

- 형식을 맞추는 목적
  - 코드 형식은 중요하다!
  - 코드 형식은 의사소통의 일환이다
  - 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다



- 적절한 행 길이를 유지하라

  - 작은 행의 파일들로도 커다란 시스템을 구축할 수 있다
  - 신문 기사처럼 작성하라
    - 이름은 간단하면서도 설명이 가능하게
    - 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명
    - 아래로 내려갈수록 의도를 세세하게 묘사
    - 마지막에는 가장 저차원 함수와 세부 내역
  - 개념은 빈 행으로 분리하라
    - 패키지 선언부, import문, 각 함수 사이 등
    - 빈 행은 새로운 개념을 시작한다는 시각적 단서
    - 빈 행을 잘 사용하면 코드의 가독성이 눈에 띄게 좋아짐
  - 세로 밀집도
    - 줄바꿈이 개념은 분리한다면, 세로 밀집도는 연관성을 의미
    - 서로 밀접한 코드 행은 세로로 가까이 놓아야 함
  - 수직 거리
    - 서로 밀접한 개념은 세로로 가까이 둬야 함
    - 타당한 근거가 없다면 밀접한 개념은 한 파일에 속해야 마땅함
    - 세로 거리는 연관성을 표현하며, 연관성은 한 개념을 이해하는 데 다른 개념이 중요한 정도
  - 변수 선언
    - 변수는 사용하는 위치에 최대한 가까이 선언
    - 지역 변수는 각 함수 맨 처음에 선언 (다소 짧은 함수)
  - 종속 함수
    - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치
    - 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치

  - 개념적 유사성

    - 개념적인 친화도가 높은 코드는 가까이 배치

    - 종속 함수 외에도 비슷한 동작을 수행하는 함수

  - 세로 순서

    - 호출하는 함수를 호출되는 함수보다 먼저 배치
    - 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려감

  

- 가로 형식 맞추기

  - 120자 정도가 최대 길이로 적당
  - 가로 공백과 밀집도
    - 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현
  - 가로 정렬
    - 정렬하지 않으면 오히려 중대한 결함을 찾기 쉬움
    - 정렬이 필요할 정도로 목록이 길다면 문제는 목록 길이이지 정렬 부족이 아님
  - 들여쓰기
    - 범위로 이루어진 계층을 표현하기 위해 코드를 들여씀
    - 들여쓰기한 파일은 구조가 한눈에 들어옴
  - 들여쓰기 무시하기
    - 때로는 간단한 if문, 짧은 while문, 짧은 함수에서 들여쓰기 규칙을 무시하고픈 유혹이 생김
    - 들여쓰기로 범위를 제대로 표현한 코드를 선호
  - 가짜 범위
    - 빈 while 문이나 for문에서 세미콜론을 시 행에다 제대로 들여써서 넣어줌



- 팀 규칙
  - 팀에 속한다면 자신이 선호해야할 규칙은 팀 규칙
  - 팀은 한 가지 규칙에 합의하고 모든 팀원은 그 규칙을 따라야함
  - 스타일은 일관적이고 매끄러워야함

​	



## 06. 객체와 자료 구조

- 자료 추상화
  - 구현을 감추려면 추상화가 필요
  - 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스
  - 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋음 (why..?)
  - 인터페이스나 조회/설정 함수만으로 추상화가 이뤄지지 않음



- 자료 / 객체 비대칭
  - 객체 (다형적)
    - 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개
    - 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉬움
    - 새로운 함수를 추가하기 어려움 -> 모든 클래스를 고쳐야함
  - 자료 구조 (절차적)
    - 자료를 그대로 공개하며 별다른 함수를 제공하지 않음
    - 기본 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉬움
    - 새로운 자료 구조를 추가하기 어려움 -> 모든 함수를 고쳐야 함
  - 모든 것이 객체라는 생각은 좋지 않음 => 때로는 단순한 자료 구조와 절차적 코드가 가장 적합하기도 함



- 디미터 법칙
  - 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙
  - 객체는 자료를 숨기고 함수를 공개 => 조회 함수로 내부 구조를 공개하면 안 됨
  - 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다
    - 클래스 C
    - f가 생성한 객체
    - f 인수로 넘어온 객체
    - C 인스턴스 변수에 저장된 객체
  - 기차 충돌
    - 객체가 기차처럼 이어지는 코드 (객체의 객체의 객체의 객체..)
  - 잡종 구조
    - 절반은 객체, 절반은 자료 구조
    - 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어려움
    - 잡종 구조는 되도록 피하자



- 자료 전달 객체
  - 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스
  - 이를 자료 전달 객체(Data Transfer Object <Sub>DTO</Sub>) 라고 함
  - DB에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체



## 07. 오류 처리

- 오류 코드보다 예외를 사용하라

  - 오류가 발생하면 try catch 문으로 예외를 던지는 편이 코드가 더 깔끔해진다
  - 각 개념이 독립적으로 되므로 코드 품질도 좋아짐 

  

- Try-Catch-Finally 문부터 작성하라

  - try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있음
  - try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지
  - TDD 시 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장



- 미확인 예외를 사용하라
  - 확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 따져봐야함
  - 확인된 예외는 OCP(Open Closed Principle)를 위반함 => 캡슐화를 깨버림
  - 아주 중요한 라이브러리를 작성한다면 모든 예외를 잡아야 좋음
  - 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 큼



- 예외에 의미를 제공하라
  - 예외를 던질 때는 전후 상황을 충분히 덧붙인다
  - 오류 메시지에 정보를 담아 예외와 함께 던진다
  - 실패한 연산 이름과 실패 유형도 언급
  - 로깅 기능도 사용



- 호출자를 고려해 예외 클래스를 정의하라
  - 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법
  - 외부 API를 사용할 때는 감싸기 기법이 최선
  - 외부 라이브러리와 프로그램 사이의 의존성이 크게 줄어듬



- 정상 흐름을 정의하라
  - 특수 사례 패턴
    - 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식
    - 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어짐



- null을 반환하지 마라
  - null을 반환하는 습관은 오류를 만든다 => Java 이야긴듯..?
  - null 확인이 많아지는 코드가 문제
  - 예외를 던지거나 특수 사례 객체를 반환하자



- null을 전달하지 마라
  - null을 전달하는 방식은 더 나쁘다
  - 정상적인 인수로 null을 기대하는 API 가 아니라면 메서드로 null을 전달하는 코드는 최대한 피하자





## 08. 경계

- 인트로
  - 시스템에 들어가는 모든 소프트웨어를 개발하는 경우는 드뭄
  - 때로는 패키지나 오픈소스를 사용
  - 어떤 식이든 외부 코드를 우리 코드에 깔끔하게 통합해야 함



- 외부 코드 사용하기
  - 인터페이스 제공자는 적용성을 최대한 넓히려고 애쓰고, 사용자는 자신의 요구에 집중하는 인터페이스를 바람
  - 이 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많음
  - 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출 되지 않도록 주의
  - 경계 인터페이스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않아야 함



- 경계 살피고 익히기
  - 외부 패키지 테스트가 우리 책임은 아니지만 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직
  - 학습 테스트
    - 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 법
    - 프로그램에서 사용하려는 방식대로 외부 API를 호출
    - API를 사용하려는 목적에 초점을 맞춤



- 학습 테스트는 공짜 이상이다
  - 외부 API를 배워야하기에 학습 테스트에 드는 비용은 없다
  - 오히려 필요한 지식만 확보하고 이해도를 높여주는 정확한 실험임
  - 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인



- 아직 존재하지 않는 코드를 사용하기
  - 아는 코드와 모르는 코드를 분리하는 경계
  - 때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있음
  - 우리가 바라는 인터페이스를 구현해 우리가 인터페이스를 전적으로 통제하자
  - 그러면 테스트가 아주 편해짐



- 깨끗한 경계
  - 통제하지 못하는 코드를 사용할 때는 너무 많은 투자를 하거나 향후 변경 비용이 지나치게 커지지 않도록 각별히 주의
  - 경계에 위치하는 코드는 깔끔히 분리
  - 기대치를 정의하는 테스트 케이스도 작성
  - 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋음
  - 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리
