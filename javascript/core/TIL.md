# 코어 자바스크립트 정리

### 01. 데이터 타입

- 데이터 타입의 종류 ?

  - 기본형<sup>primitive type</sup> : number, string, boolean, null, undefined, Symbol

    - 심볼 타입

      - ES6에서 추가된 7번째 타입
      - 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값

      ```js
      var key = Symbol('key');
      var obj = {};
      obj[key] = 'value';
      console.log(obj[key]); //value
      ```

    - 값이 담긴 주솟값을 바로 복제

    - 불변성<sup>immutability</sup>

  - 참조형<sup>reference type</sup> : Object, Array, Function, Date, RegExp, Map, Set

    - 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제
    - 가변성<sup>mutability</sup>

- 메모리와 데이터

  - 비트
    - 0또는 1로만 표현할 수 있는 하나의 메모리 조각
    - 고유한 식별자를 통해 위치를 확인할 수 있음
  - 바이트
    - 8bit로 구성
    - 시작하는 비트의 식별자로 위치를 파악할 수 있음
    - 모든 데이터는 바이트 단위의 식별자, **메모리 주솟값** 을 통해 서로 구분하고 연결됨

- 식별자와 변수

  - 변수 
    - 변할 수 있는 데이터
  - 식별자
    - 어떤 데이터를 식별하는데 사용하는 이름 -> **변수명**

- 변수 선언과 데이터 할당

  - 변수 선언

    ```js
    var a;
    => 변할 수 있는 데이터를 만들고, 이 데이터의 식별자는 a가 된다
    ```

  - 변수 : 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇

  - 데이터 할당

    ```js
    var a;
    a = 'abc';
    
    var a = 'abc';
    ```

    - 위 두 방법은 같은 동작을 수행
      - a는 임의의 주소에 이름과 값이 할당되고, 이 값은 실제 데이터가 할당 되어 있는 주소를 가리킴
      - a가 가리키는 주소에 'abc'를 데이터로 할당됨
    - 변수 영역에 값을 직접 대입하지 않는 이유?
      - 데이터 변환을 자유롭게 할 수 있고 메모리를 더 효율적으로 관리할 수 있음
      - 가변적인 데이터 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적 
      - 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아짐

- 기본형 데이터와 참조형 데이터

  - 불변값
    - 변수와 상수 : 구분하는 성질은 **변수 영역** 메모리의 '변경 가능성'
    - 불변과 가변 : 구분하는 성질은 **데이터 영역** 메모리의 '변경 가능성'
    - 불변값 
      - 기본형 데이터 : 숫자, 문자열, boolean, null, nudefined, Symbol
      - 변경은 새로 만드는 동작을 통해서만 이루어짐
      - 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않음
    - Garbage Collector ?
      - https://ko.javascript.info/garbage-collection
  - 가변값
    - 보통의 참조형 데이터 : object, array 등
    - 데이터 영역에 저장된 값은 불변값이지만, 변수에는 다른 값을 얼마든지 대입할 수 있음
    - 참조 카운트 : 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수
    - 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 됨
  - 변수 복사 비교
    - 자바스크립트의 모든 데이터 타입은 참조형 데이터
    - 기본형 : 주솟값을 복사하는 과정이 한 번만 이루어지기 때문에 복사한 값이 변했을 때도 원본은 유지됨
    - 참조형 : 참조형 데이터 자체를 변경할 경우에는 기본형과 똑같이 기존 데이터는 변하지 않지만, 그 내부의 프로퍼티를 변경하면 원본이 함께 변경됨

- 불변 객체

  - 불변 객체를 만드는 가장 간단한 방법 ? 객체를 복사할 때, 새로운 객체를 만들어 리턴해주기
  - 얕은 복사와 깊은 복사
    - 깊은 복사를 위해서는 **기본형 데이터일 경우에는 그대로 복사**하면 되지만, **참조형 데이터는 다시 그 내부의 프로퍼티들을 복사**해야 함
    - 깊은 복사 방법 
      - 참조형 데이터가 있을 때마다 내부 프로퍼티들을 순회하며 재귀적으로 함수를 호출하는 방법
      - JSON 활용하기
        - But, `메서드`나 `__proto__`, `getter/setter` 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 무시함
        - `httpRequest`로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋음

- undefined와 null
  - undefined
    - 사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 JS 엔진이 자동으로 부여하는 경우도 있음
      1. 값을 대입하지 않은 변수(var)에 접근할 때
      2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
      3. return 문이 없거나 호출되지 않는 함수의 실행 결과
    - '비어있는 요소'와 달리 'undefined를 할당한 요소'는 순회와 관련된 많은 배열 메서드들의 순회 대상에 포함됨
    - 비어있는 요소는 값이 지정되지 않은 인덱스이므로 '존재하지 않는 프로퍼티'에 지나지 않음
    - 직접 undefined를 할당하는 것을 피하는 것을 추천함
  - null
    - 값이 없음을 나타내고자 할 때는 null을 사용하는 것을 권장
      - 이 규칙을 따르는 한 undefined는 '값을 대입하지 않는 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값'으로서만 존재할 수 있음
    - typeof 를 사용했을 때 object로 나타나는 자바스크립트 자체 버그가 있음
      - https://curryyou.tistory.com/183
    - null 여부를 판단하기 위해서는 일치 연산자(===)를 써야 정확히 판단이 가능

