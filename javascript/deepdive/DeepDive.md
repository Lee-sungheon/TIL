# 모던 자바스크립트 Deep Dive 정리

> '모던 자바스크립트 Deep Dive' 라는 서적을 공부하며 자바스트립트의 원리와 개념에 대한 이해를 높이고 900page라는 방대한 양을 나중에 다시 공부하기 쉽게 내가 이해한바를 정리하는 문서입니다.



## 01. 프로그래밍

- 프로그래밍 
  - 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션
  - 기계에게 정확하고 상세하게 요구사항을 설명하는 작업 => 컴퓨팅 사고 필요
  - 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것
- 컴파일러<sup>compiler</sup>(혹은 인터프리터<sup>interpreter</sup>) : 사람이 이해할 수 있는 약속된 구문으로 구성된 `프로그래밍 언어`를 사용해 프로그램을 작성한 후, 그것을 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 번역기



## 02. 자바스크립트

- 자바스크립트의 표준화
  - 자바스크립트의 파편화(크로스 브라우징 이슈 발생)를 방지하고 모든 브라우저에서 정상적으로 동작하는 표준화된 자바스크립트의 필요성이 대두
  - ECMAScript로 명명
  - ES5 (2009) 
    - HTML5와 함께 출현한 표준안
    - JSON, strict mode, 접근자 프로퍼티, 프로퍼티 어트리뷰트 제어, 향상된 배열 조작 기능
  - ES6 (2015)
    - 범용 프로그래밍 언어로서 갖춰야 할 기능들을 대거 도입
    - let/const, 클래스, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, 심벌, 프로미스, Map/Set, 이터러블, for...of, 제너레이터, Proxy, 모듈 import/export
  - ES11(2020)
    - 가장 최근 버전
    - 옵셔널 체인닝 연산자, BigInt, globalThis, null 병합 연산자, String.prototype.matchAll
- Ajax<sup>Asynchronous JavaScript and XML</sup>
  - 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할수 있는 통신 기능
  - 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링이 가능해짐
- V8 자바스크립트 엔진
  - 구글에서 등장한 빠르게 동작하는 자바스크립트 엔진
  - V8의 등장으로 과거 웹 서버에서 수행되는 로직들이 대거 클라이언트로 이동했고, 이는 웹 개발에서 프론트엔드 영역이 주목받는 계기로 작용
- Node.js
  - 2009년, 라이언 달이 발표한 구글 V8로 빌드된 자바스크립트 런타임 환경
  - 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경
  - SSR에 주로 사용되며, 이에 필요한 모듈, 파일 시스템, HTTP 등 빌드인 API를 제공
  - 비동기 I/O를 지원하며 단일 스레드 이벤트 루프 기반으로 동작 
    - 요청 처리 성능이 좋음
    - 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 SPA에 적합
    - CPU 사용률이 높은 애플리케이션에서는 권장 X
- 자바스크립트의 특징
  - 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
  - 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**
  - 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 **멀티 패러다임 프로그래밍 언어**
  - 클래스 기반 객체지향 언어보다 효율적이면서 강력한 **프로토타입 기반의 객체지향 언어**



## 03. 개발 환경과 실행 방법

- 실행 환경
  - 브라우저와 Node.js는 자바스크립트 엔진을 내장하고 있으므로 브라우저 환경 또는 Node.js 환경에서 실행 가능
  - 공통적으로 ECMAScript를 실핼할 수 있음
  - But, 브라우저와 Node.js는 용도가 다름
    - 브라우저는 클라이언트  사이드 Web API를 지원
    - Node.js는 Node.js 고유의 API를 지원
- 개발자 도구
  - Elements : 로딩된 웹페이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인 가능
  - Console : 로딩된 웹페이지의 에러를 확인하거나 자바스크립트 소스코드에 작성한 console.log 메서드의 실행 결과를 확인할 수 있음
  - Sources : 로딩된 웹페이지의 자바스크립트 코드를 디버깅할 수 있음
  - Network : 로딩된 웹페이지에 관련된 네트워크 요청 정보와 성능을 확인할 수 있음
  - Application : 웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있음

- npm<sup>node package manager</sup> 
  - 자바스크립트 패키지 매니저
  - Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할*
  - 패키지 설치 및 관리를 위한 CLI 를 제공
  - 자신이 작성한 패키지를 공개할 수도 있고, 필요한 패키지를 검색해 재사용할 수도 있음



## 04. 변수

- 변수<sup>variable</sup>
  - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
  - 값을 위치를 가리키는 상징적인 이름
  - 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행
  - **할당** : 변수에 값을 저장하는 것
  - **참조** : 변수에 저장된 값을 읽어들이는 것
  - 명확한 네이밍을 통해 코드를 이해하기 쉽게 만들고, 협업과 품질 향상에 도움을 줄 수 있음

- 식별자<sup>identifier</sup>

  - 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름
  - 식별자는 값이 아니라 메모리 주소를 기억하고 있음

- 변수 선언

  - 변수를 사용하기 위해 선언이 필요
  - `var`, `let`, `const` 키워드를 사용
  - 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생

- 변수 호이스팅 

  - 변수 선언은 소스코드가 순차적으로 샐행되는 런타임 이전 단계에서 먼저 실행
  - 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징
  - 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행

- 네이밍 컨벤션

  ```js
  // 카멜 케이스(camelCase)
  var firstName;
  
  // 스네이크 케이스(snake_case)
  var first_name;
  
  // 파스칼 케이스(PascalCase)
  var FisrtName;
  
  // 헝가리언 케이스(typeHungarianCase)
  var strFisrtName;
  var $elem = document.getElementById('myId');
  var observable$ = fromEvent(document, 'click');
  ```

  - 일반적으로 변수나 함수의 이름에는 **카멜 케이스** / 생성자 함수, 클래스의 이름에는 **파스칼 케이스**를 사용



## 05. 표현식과 문

- 값(value)
  - 식이 평가되어 생성된 결과
  - 변수는 **하나의 값**을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
  - 변수에 할당되는 것은 값임 

- 리터럴(literal)
  - 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
  - (아라비아 숫자, 알파벳, 한글) 또는 (' ', " ", [], {}, //)

- 표현식(expression)
  - 값으로 평가될 수 있는 문
  - 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조
- 문(statement)
  - 프로그램을 구성하는 기본 단위이자 최소 실행 단위
  - 여러 토큰으로 구성
  - 토큰 : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 (키워드, 식별자, 리터럴, 세미콜론, 마침표 등)
- 표현식인 문과 표현식이 아닌 문의 구별
  - 가장 간단하고 명료한 방법은 변수에 할당해 보는 것

- 세미콜론(;)
  - 문의 종료를 나타냄
  - 0개 이상의 문을 중괄호로 묶은 코드 블록(`{ ... }`) 뒤에는 세미콜론을 붙이지 않음
    - 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문
  - 생략 가능 -> 자바스크립트 엔진의 세미콜론 자동 삽입 기능(ASI)
  - ESLint 및 TC39(ECMA 기술 위원회)에서 세미콜론 사용을 권장하는 분위기이므로 사용하는 것을 추천



## 06. 데이터 타입

- 데이터 타입

  - 원시 타입

    - 숫자 타입

      - 주로 산술 연산을 위해 사용
      - 배정밀도 64비터 부동소수점 형식
      - 모든 수를 실수로 처리, 정수로 표현하기 위한 데이터 타입이 별도로 존재하지 않음
      - Infinity(양의 무한대) / -Infinity(음의 무한대) / NaN(산술 연산 불가) 도 표현 가능

    - 문자열 타입

      - 텍스트 데이터를 나타내는데 사용
      - 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합
      - ' ', " ", `` 으로 텍스트를 감쌈

    - 불리언 타입

      - 논리적 참, 거짓을 나타내는 `true` 와 `false`로 구성

    - undefined 타입

      - var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화됨
      - 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(대부분 쓰레기 값)로 내버려두지 않기 위함
      - 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이므로 개발자가 의도적으로 변수에 할당하는 것은 권장하지 않음 => `null`로 대체

    - null 타입

      - 변수에 값이 없다는 것을 의도적으로 명시할 때 사용
      - 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 함
        - ex) `document.querySelector`

    - 심벌 타입

      - ES6에서 추가된 7번째 타입
      - 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값

      ```js
      var key = Symbol('key');
      var obj = {};
      obj[key] = 'value';
      console.log(obj[key]); //value
      ```

  - 객체 타입

    - 자바스크립트는 객체 기반의 언어
    - 자바스크립트를 이루고 있는 거의 모든 것이 객체
    - 원시 타입 외에는 모두 객체 타입

- 템플릿 리터럴

  - 멀티라인 문자열

    - 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용됨

    ```js
    var template = `<ul>
    	<li><a href="#">Home</a></li>
    </ul>`;
    ```

  - 표현식 삽입

    - 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있음
    - 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있음

    ```js
    var first = "Lee";
    var last = "Sungheon";
    
    console.log(`My name is ${first} ${last}`);
    console.log(`1 + 2 = ${1 + 2}`);
    ```

- 데이터 타입이 필요한 이유

  - 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
  - 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
  - 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

- 동적 타입 언어
  - 자바스크립트는 변수를 선언할 때 타입을 선언하지 않음
  - 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있음
  - 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론<sup>type inference</sup>)
  - 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음 => 동적 타이핑
  - 동적 타입 언어는 유연성은 높지만 신뢰성이 떨어짐
  - 주의 사항
    - 변수는 꼭 필요한 경우에 한해 제한적으로 사용
    - 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용 억제
    - 전역 변수는 최대한 사용하지 않도록 함
    - 변수보다는 상수(`const`) 를 사용해 값의 변경을 억제
    - 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍



> 컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다. 하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다.
>
> -마틴 파울러, <리팩토링>의 저자



## 07. 연산자

- 산술 연산자

  - 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듬
  - 산술 연산이 불가능한 경우, `NaN`을 반환
  - 이항 산술 연산자
    - +, -, *, /, %
    - 2개의 피연산자를 산술 연산하여 숫자 값을 만듬
    - 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과가 없음
  - 단항 산술 연산자
    - ++, --, +, -
    - 1개의 피연산자를 산술 연산하여 숫자 값을 만듬
    - `++`, `--` 연산자는 피연산자의 값을 변경하는 부수 효과가 있음
  - 문자열 연결 연산자
    - `+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

- 할당 연산자

  - +=, -=, *=, /=, %=
  - 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있음

- 비교 연산자

  - 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환
  - if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용
  - 동등 비교 연산자(==)
    - 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교
    - 예측하기 어려운 결과를 만들어내므로 사용하지 않는 편이 좋음

  - 일치 비교 연산자(===)

    - 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환

    - `NaN`은 자신과 일치하지 않는 유일한 값이므로 숫자가 `NaN`인지 조사하려면 빌트인 함수 `isNaN`를 사용해야함

      ```js
      NaN === NaN; // -> false
      isNaN(NaN); // -> true
      isNaN(10); // -> false
      isNaN(1 + undefined) // -> true
      Object.is(NaN, NaN); // -> true
      ```

    - 양의 0과 음의 0을 비교하면 true를 반환

      ```js
      0 === -0; // -> true
      Object.is(-0, +0); // -> false
      0 == -0; // -> true
      ```

  - 대소 관계 비교 연산자

    - 피연산자의 크기를 비교하여 불리언 값을 반환

- 삼항 조건 연산자

  - `조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값`

  - 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문
  - 조건에 따라 어떤 값을 결정해야 한다면 **삼항 조건 연산자**
  - 조건에 따라 수행해야 할 문이 하나가 아니라 여러개면 **if ...else**

- 논리 연산자

  - 우항과 좌항의 피연산자를 논리 연산함
  - ||, &&, !

- 쉼표 연산자

  - 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평과 결과를 반환

    ```js
    var x, y, z;
    x = 1, y = 2, z = 3; // 3
    ```

- 그룹 연산자

  - 연산자 우선순위가 가장 높음
  - 그룹 연산자를 사용하면 연산자의 우선 순위를 조절할 수 있음

- typeof 연산자

  - 피연산자의 데이터 타입을 문자열로 반환
  - string, number, boolean, undefined, symbol, object, function 중 하나를 반환
  - null 은 object로 반환

- 지수 연산자

  - 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환
  - ES7에서 도입

- 연산자 우선순위

  | 우선순위 | 연산자                                    |
  | :------: | :---------------------------------------- |
  |    1     | ()                                        |
  |    2     | new(매개변수 존재), ., [], (), ?.         |
  |    3     | new(매개변수 미존재)                      |
  |    4     | x++, x--                                  |
  |    5     | !x, +x, -x, ++x, --x, typeof, delete      |
  |    6     | **(이항 연산자 중에서 우선순위 가장 높음) |
  |    7     | *, /, %                                   |
  |    8     | +, -                                      |
  |    9     | <, <=, >, >=, in, instanceof              |
  |    10    | ==, !=, ===, !==                          |
  |    11    | ?? (null 병합 연산자)                     |
  |    12    | &&                                        |
  |    13    | \|\|                                      |
  |    14    | ? ... : ...                               |
  |    15    | 할당 연산자(=, +=, -=, ....)              |
  |    16    | ,                                         |



## 08. 제어문

- break 문

  - 중첩된 for 문의 내부 for 문에서 외부 for 문을 탈출하기 위해 레이블 문을 사용

    ```js
    outer: for (var i = 0; i < 3; i++) {
    	for (var j = 0; j < 3; j++) {
            if (i + j === 3) break outer;
        }
    }
    ```



## 09. 타입 변환과 단축 평가

- Falsey 값

  - false
  - undefined
  - null
  - 0, -0
  - NaN
  - ''

- 명시적 타입 변환

  - 문자열 타입으로 변환

    1. String 생성자 함수를 new 연산자 없이 호출하는 방법	

       ```js
       String(1);
       String(NaN);
       String(Infinity);
       String(true);
       ```

    2. Object.prototype.toString 메서드를 사용하는 방법

       ```js
       (1).toString();
       (NaN).toString();
       (true).toString();
       ```

    3. 문자열 연결 연산자를 이용하는 방법

       ```js
       1 + '';
       true + '';
       ```

  - 숫자 타입으로 변환

    1. Number 생성자 함수를 new 연산자 없이 호출하는 방법

       ```js
       Number('0');
       Number('-1');
       Number(true);
       ```

    2. parseInt, parseFloat 함수를 사용하는 방법 (문자열만 가능)

       ```js
       parseInt('0');
       parseFloat('10.53');
       ```

    3. `+` 단항 산술 연산자를 이용하는 방법

       ```js
       +'0';
       +'10.53';
       +true;
       ```

    4. `*` 산술 연산자를 이용하는 방법

       ```js
       '0'*1;
       '10.53'*1;
       true*1;
       ```

  - 불리언 타입으로 변환

    1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법

       ```js
       Boolean('x');
       Boolean(NaN);
       ```

    2. ! 부정 논리 연산자를 두 번 사용하는 방법

       ```js
       !!'x';
       !!NaN;
       ```

- 옵셔널 체이닝 연산자

  - ES11 에서 도입

  - `?.` 는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어감

    ```js
    var elem = null;
    var value = elem?.value;
    console.log(value); // undefined
    ```

- null 병합 연산자

  - ES11 에서 도입

  - `??` 는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환

  - 변수에 기본값을 설정할 때 유용

    ```js
    var foo = null ?? 'default string';
    console.log(foo); // "defalut string"
    ```



## 10. 객체 리터럴

- 객체
  - 자바스크립트는 객체 기반의 프로그래밍 언어
  - 자바스크립트를 구성하는 거의 모든 것이 객체
  - 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성됨
    - 프로퍼티: 객체의 상태를 나타내는 값(data)
  - 함수로 이루어진 프로퍼티는 `메서드` 라고 명칭함
    - 메서드: 프로퍼티(상태 데이터)를 참고하고 조작할 수 있는 동작(behavior)
- 객체 생성법
  - 객체 리터럴
    - 객체를 생성하는 가장 일반적이고 간단한 방법
    - `{ ... }`  내에 0개 이상의 프로퍼티를 정의
    - 객체 리터럴의 중괄호는 코드 블록을 의미하는 것이 아니므로 뒤에 세미콜론`(;)` 을 붙임 
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스(ES6)

- 프로퍼티

  - **객체는 프로퍼티의 집합이며, 키와 값으로 구성됨**

  - 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값

  - 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

  - 식별자 네이밍 규칙을 따르면 따옴표가 생략 가능하나, 따르지 않는 이름에는 반드시 따옴표를 사용해야함

    ```js
    var person = {
      firstName: 'Ung-mo',
      'last-name': 'Lee'
    };
    ```

  - 프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 됨
  - 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어씀

- 프로퍼티 접근

  - 마침표 프로퍼티 접근 연산자(.)를 사용하는 **마침표 표기법**
  - 대괄호 프로퍼티 접근 연산자([...])를 사용하는 **대괄호 표기법**
    - 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열
    - 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 반환

- 프로퍼티 축약 표현

  - ES6 에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있음

  - 이 때 프로퍼티 키는 변수 이름으로 자동 생성

    ```js
    // ES5
    var x = 1, y = 2;
    var obj = {
      x: x,
      y: y
    };
    
    // ES6
    let x = 1, y = 2;
    const obj = { x, y };
    console.log(obj); // { x: 1, y: 2 }
    ```

- 계산된 프로퍼티 이름

  - ES6에서는 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있음

    ```js
    // ES5
    var prefix = 'prop';
    var i = 0;
    var obj = {};
    obj[prefix + '-' + ++i] = i;
    obj[prefix + '-' + ++i] = i;
    obj[prefix + '-' + ++i] = i;
    
    // ES6
    const prefix = 'prop';
    let i = 0;
    
    const obj = {
      [`${prefix}-${++i}`]: i,
      [`${prefix}-${++i}`]: i,
      [`${prefix}-${++i}`]: i
    };
    
    console.log(obj); // { pro-1: 1, prop-2: 2, prop-3: 3 }
    ```

- 메서드 축약 표현

  - ES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있음

    ```js
    // ES5
    var obj = {
      name: 'Lee',
      sayHi: function() {
        console.log('Hi' + this.name);
      }
    };
    
    // ES6
    const obj = {
      name: 'Lee',
      sayHi() {
        console.log('HI' + this.name);
      }
    };
    ```

    

## 11. 원시 값과 객체의 비교

- 원시 값
  - 원시 타입의 값, 즉 변경 불가능한 값<sup>immutable value</sup>
  - 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술
  - 값에 의한 전달
    - 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문
    - "값에 의한 전달"도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달
    - 단, 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음
    - 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없음
- 객체
  - 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음
  - 프로퍼티 키를 인덱스로 사용하는 해시 테이블 자료 구조를 사용
  - 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있음 => 사용하긴 편리하지만 성능 면에서는 이론적으로 클래스 기반 객체지향 프로그래밍 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식
  - V8 엔진은 **히든 클래스** 방식을 사용해 C++ 객체 정도의 성능을 보장함
    - [참고 자료](https://meetup.toast.com/posts/78)
  - 객체 타입의 값은 변경 가능한 값<sup>mutable value</sup>
  - 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음
  - 여러 개의 식별자가 하나의 값을 객체를 공유할 수 있다는 단점이 있음 (얕은 복사, 깊은 복사)



## 함수

- 함수란?
  - 일련의 과정을 문으로 구현하고 코드 블록으로 감싸사 하나의 실행단위로 정의한 것
  - 함수 내부로 입력을 전달받는 변수를 **매개변수**<sup>parameter</sup>, 입력을 **인수**<sup>argument</sup>, 출력을 **반환값**<sup>return value</sup> 라고 함
  - 함수는 코드의 중복을 억제하고 재사용성을 높이는 **유지보수의 편의성**을 높이고 실수를 줄여 **코드의 신뢰성**을 높이는 효과가 있음
  - 적절한 함수 이름은 함수 내부의 코드를 이해하지 않고도 함수의 역할을 파악하게 돕기 때문에 **코드의 가독성**을 향상시킴

