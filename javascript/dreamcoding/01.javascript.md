## JavaScript

#### ES ? 

- ECMAScript
- 현재 모든 브라우져들이 ECMAScript의 표준을 따라가고 있음
- ES6 : class, arrow function, const / let, default parameter 등의 문법이 나옴
- 현재 ES 11 버전까지 나옴



####  Babel

- JavaScript transcompiler

- 개발할 때는 최신 버전의 ECMAScript를 쓰고 사용자에게 배포할 때 ECMAScript의 최신 버전을 5나 6로 코드로 변환해주는 역할




#### Webpack

- 모듈 번들러 : 여러개의 파일을 하나의 파일로 묶어주는 라이브러리
- Why Webpack?
  - 네트워크 병목현상 최소화
    - 너무 많은 자바스크립트 파일을 로드할 경우, 네트워크의 병목현상이 발생하는데 모듈 번들러는 여러 파일을 하나의 파일로 묶어주기 때문에, 네트워크 병목현상을 최소화 할 수 있음
  - 모듈단위 개발
    - 가독성과 유지보수 효율을 높임
    - 스코프에 신경쓰지 않고 개발이 가능
    - 라이브러리 종속 순서를 신경쓰지 않아도 됨
  - 코드를 압축 / 최적화
  - ES6 이상의 자바스크립트 사용이 가능
    - babel-loader
  - LESS, SCSS를 사용 가능
    - style-loader / css-loader



#### SPA

- Single Page Application
  
  - framework : react, angular, vue 등
  



#### 공식 사이트

- ecma-international.org -> 개발자가 보기엔 난해할 수도 있음
- developer.mozilla.org -> 개발자가 자주 찾는 사이트



#### asyn vs defer

- asyn
  - `<script asyn src="a.js"></script>`
  - 스크립트를 비동기적으로 다운받고 다운이 완료되는대로 실행
  - 순서의존적인 자바스크립트라면 오류 발생 가능성이 높음
- defer
  - `<script defer src="a.js"></script>`
  - html을 parsing하는 동안 스크립트를 비동기적으로 다운받고 html이 parsing이 완료되면 script의 순서대로 실행됨
  - 가장 추천하는 방법
  
  

#### use strict

- 파일 제일 상단에 `'use strict';`
- ES5에서 도입, js에서 일어날 수 있는 오류들을 잡아줌



#### 변수

- let 
  - ES6+ 이후 도입
  - mutable
  - 변수 할당이 가능
  - block scope가 있음
- var
  - 선언 전에 값을 할당할 수 있음 
    - var hoisting : 어디에서 선언했냐와 상관없이 항상 제일 위로 선언을 끌어올려주는 것
  - block scope가 없음
  - 사용하지 않을 것을 권장 (let으로 대체)
- const
  - 한번 선언하면 값이 절대 바뀌지 않는 변수 (immutable)
    
    - 보안, 쓰레드 안전, 휴먼 에러를 줄여주는 장점을 가짐
    
    

#### Variable Type

- primitive, single item: number, string, boolean, null, undefined, symbol
- object, box container
- function, first-class function
- bigInt : 숫자뒤에n을 붙이면 됨 (12312412n) => 매우 큰 범위의 수를 다룰 때 사용
- template literals : ```(백틱)`을 이용``
- boolean : false(0, null, undefined, NaN, '')
- null : 값이 없음을 선언
- undefined : 선언은 됐으나 값은 할당되지 않은 상태
- symbol : 고유한 식별자를 만들 때 사용



#### Equality

- == 
  - loose equality, with type conversion
- ===
  - strict equality, no type conversion



#### Ternary operator

- `name==='ellie' ? 'yes' : 'no';`



#### function

- Early return, early exit

  - 조건에 맞지 않은것은 최대한 빨리 return 하는 것이 좋은 코드

- Arrow function

  - anoymous function (이름이 없는 함수)
  - 함수를 간결하게 만들어줌
  - `() => { return } `

- IIFE(Immediately Invoked Function Expression)

  - 함수를 선언과 동시에 실행시킬 수 있음

  ```javascript
  (function hello() {
      console.log("IIFE");
  })();
  ```



#### Object

- Object.key = value 로 추가 기능

- delete Object.key 로 삭제 가능
- **object.key** vs **object['key']**
  - object.key 
    - 그 key에 정말 해당하는 값을 받아오고 싶을 때
    - 평상시 코딩을 할 때 닷(.)을 사용
  - object['key']
    - computed properties
    - 우리가 정확하게 어떤 key가 필요한지 모를 때
- in operator 
  - 해당하는 key가 object에 있는지 확인 가능
  - `'key' in object`
- clone
  - Object.assign(copy, target)



#### Array

- forEach

  - callback 함수

  - ```js
    array.forEach((value, index) => {
        console.log(value, index)
        return
    })
    ```

- Array APIs

  - 추가 : push, unshift

  - 삭제 

    -  pop, shift
      - shift, unshift 는 배열의 앞부분을 조작하므로 느림
    - splice()
      - array.splice(index, length, addval)
      - length를 지정하지 않으면 index부터 모두 지움
      - addval 값을 넣으면 지우고 추가 데이터를 삽입 가능

  - 결합

    - concat()

      `array.concat(array2)`

  - 검색

    - indexOf() : 존재시 index, 비존재시 -1 반환

      `array.indexOf(value)`

    - lastIndexOf() : 해당 value를 가지는 마지막 해당하는 index 반환

    - includes() : 존재 유무를 boolean 형태로 반환

      `array.includes(value)`

      

#### JSON

- JSON 

  - JavaScript Object Notation
  - data format
  - server와 데이터를 주고받을 때
  - object를 file system에 저장할 때

- Object to JSON

  - stringify(obj)

    ```js
    let json = JSON.stringify(object);
    ```

  - stringify(object, function(){}), stringfiy(object, [])의 형태로도 사용 가능

- JSON to Object

  - parse(json)

    ```js
    const obj = JSON.parse(json);
    ```



# Event Loop?

![img](https://miro.medium.com/max/2048/1*4lHHyfEhVB0LnQ3HlhSs8g.png)

출처 [How JavaScript works: an overview of the engine, the runtime, and the call stack](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf)

## JS Engine

자바스크립트 엔진은 ***Memory Heap*** 과 ***Call Stack*** 으로 구성되어 있다.
가장 유명한 것이 구글의 V8 Engine이다.
자바스크립트는 ***단일 스레드 (sigle thread) 프로그래밍*** 언어인데,
이 의미는 ***Call Stack이 하나*** 라는 이야기이다.
*(멀티가 되지 않고, 하나씩 하나씩 처리한다는 의미!)*

- Memory Heap : 메모리 할당이 일어나는 곳
  (ex, 우리가 프로그램에 선언한 변수, 함수 등이 담겨져 있음)
- Call Stack : 코드가 실행될 때 쌓이는 곳. stack 형태로 쌓임.
  - Stack(스택) : 자료구조 중 하나, 선입후출(LIFO, Last In First Out)의 룰을 따른다.

## Web API

그림의 오른쪽에 있는 Wep API는 JS Engine의 밖에 그려져 있다.
즉, 자바스크립트 엔진이 아니다.
***Web API*** 는 ***브라우저에서 제공하는 API*** 로, DOM, Ajax, Timeout 등이 있다.
Call Stack에서 실행된 비동기 함수는 Web API를 호출하고,
Web API는 콜백함수를 Callback Queue에 밀어 넣는다.

## Callback Queue

***비동기적으로 실행된 콜백함수가 보관*** 되는 영역이다.
예를 들어 setTimeout에서 타이머 완료 후 실행되는 함수(1st 인자),
addEventListener에서 click 이벤트가 발생했을 때 실행되는 함수(2nd 인자) 등이 보관된다.

- Queue(큐) : 자료 구조 중 하나, 선입선출(FIFO, Frist In Frist OUT)의 룰을 따른다.

## Event Loop

Event Loop는 Call Stack과 Callback Queue의 상태를 체크하여,
***Call Stack이 빈 상태가 되면, Callback Queue의 첫번째 콜백을 Call Stack으로 밀어넣는다.***
이러한 반복적인 행동을 ***틱(tick)*** 이라 부른다.

> 정리하면,
>
> - V8 엔진에서 코드가 실행되면, Call Stack에 쌓인다.
>
> - Stack의 선입후출의 룰에 따라 제일 마지막에 들어온 함수가 먼저 실행되며,
>
>   Stack에 쌓여진 함수가 모두 실행된다.
>
>   - 비동기함수가 실행된다면, Web API가 호출된다.
>   - Web API는 비동기함수의 콜백함수를 Callback Queue에 밀어넣는다.
>   - Event Loop는 Call Stack이 빈 상태가 되면
>     Callback Queue에 있는 첫번째 콜백을 Call Stack으로 이동시킨다.
>     (이러한 반복적인 행동을 틱(tick)이라 한다.)

**자바스크립트를 단일 스레드 프로그래밍 언어라 한번에 하나씩 밖에 실행할 수 없다.
그러나 Web API, Callback Queue, Event Loop 덕분에 멀티 스레드 처럼 보여진다.** 👍

## Microtask Queue???

![img](01.javascript.assets/browser-structure.png)

출처 [자바스크립트 비동기 처리 과정과 RxJS Scheduler](http://sculove.github.io/blog/2018/01/18/javascriptflow/)

```javascript
console.log('script start'); 

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
```

콘솔창에는 어떤 순서로 실행될까?

```javascript
script start
script end
promise1
promise2
setTimeout
```

script start, script end 순으로 처리되는건 당연히 알겠는데..
왜 Promise, setTimeout 순으로 실행되는 걸까?

여기서 Microtask Queue의 개념이 나온다.

Event Loop는 우선적으로 Microtask Queue를 확인한다.
만약 ***Microtask Queue에 콜백이 있다면, 이를 먼저 Call Stack에 담는다.***
그리고 Microtask Queue에 더이상 처리해야할 콜백이 없다면,
Task Queue에 확인 후 처리한다.

***Promise의 then()의 콜백*** 은 Task Queue가 아닌 ***Microtask Queue에 담긴다.***
따라서 위 코드에서는 우선순위가 높은 Microtask Queue부터 처리되므로,
Promise의 then() 콜백이 다 실행되고, setTimeout 콜백이 실행되는 거다.



#### 비동기 처리

- callback

  - hoisting ? var, function declaration 과 같이 선언이 제일 위로 올라감
  - 함수에서 함수를 요청하는 형태를 callback이라고 함

- Promiss

  - js에서 제공하는 비동기를 간편하게 처리할 수 있도록 도와주는 Object

  - Poducer

    - 새로운 Promise가 생성됐을 때, executor이 자동적으로 실행됨.

      => 염두에 두고 프로그래밍이 필요

  - Consumer

    - 성공시 then, 오류 시 catch, finally는 무조건 실행

    ```js
    promise
    	.then(value => {
        	console.log(value);
    	})
    	.catch(error => {
        	console.log(error);
    	})
    	.finally(() => {
        	console.log('finally');
    	})
    ```

- async & await

  - async 와 await는 Promise를 간결/간편하고 동기적으로 실행되는것 처럼 보이게 만들어주는 API
  - async 와 await는 새로운 것이 추가 된게 아니라, 기존에 존재하는 Promise 위에 조금 더 간편한 API를 제공함 이런 것을 syntactic sugar 라고 한다

  ```js
  function delay(ms) {
    return new Promise (resolve => setTimeout(resolve, ms));
  }
  
  async function getApple() {
    await delay(1000);
    return `🍎`;
  }
  async function getBanana() {
    await delay(1000);
    return `🍌`;
  }
  
  // 방법 1
  async function pickFruits() {
    // 프로미스 객체는 선언 즉시 바로 실행됨
    // getApple과 getBanana는 병렬(독립적)로 실행됨
    const applePromise = getApple();
    const bananaPromise = getBanana();
    // 동기화
    const apple = await applePromise; 
    const banana = await bananaPromise;
    return `${apple} + ${banana}`;
  }
  pickFruits().then(result => console.log(result));
  
  // 방법 2: Promise APIs 사용
  function pickAllFruits() {
    return Promise.all([getApple(), getBanana()]).then(fruits => {
      return fruits.join(` + `);
    });
  }
  pickAllFruits().then(console.log);
  
  
  // 번외: 비동기 처리중 먼저 리턴하는 녀석만 출력
  function pickOnlyOne() {
    return Promise.race([getApple(), getBanana()]);
  }
  pickOnlyOne().then(console.log);
  ```

  - asnyc/await 는 비동기 코드를 작성하는 새로운 방법이다. 이전에는 비동기코드를 작성하기 위해 callback이나 promise를 사용해야 했다.
  - asnyc/await 는 실제로는 최상위에 위치한 promise에 대해서 사용하게 된다. Asnyc/await는 plain callback 이나 node callback과 함께 사용할 수 없다.
  - async/await는 promise처럼 non-blocking 이다.
  - async/await는 비동기 코드의 겉모습과 동작을 좀 더 동기 코드와 유사하게 만들어준다. 이것이 async/await의 가장 큰 장점이다.

  #### 왜 async/await가 더 나은가?

  **1.간결함과 깔끔함**

  `.then` 을 추가할 필요가 없었으며, response 를 해결하기 위한 비동기 함수를 만들 필요도 없었고,  변수를 선언하고 사용할 필요도 없어졌다. 우리는 또한 코드의 nesting도 피할 수 있었다. 우리는 이러한 작은 이점들을 얻을 수 있다.

  **2.에러 핸들링**

  async/await는 동기와 비동기 에러 모두를 `try/catch`를 통해서 처리할 수 있게 한다. `try/catch` 는 오래되었지만 좋은 접근 방식이다. promise를 사용한 아래 예제에서 `try/catch` 는 `JSON.parse` 가 실패하더라도 동작하지 않을 것이다. promise 안 쪽에서 발생한 에러이기 때문이다. 우리는 promise 상에서 `.catch` 를 호출해야하며, 에러를 처리하는 코드는 중복될 것이며 당신의 코드는 보다 더 복잡해질 것이다.

  

- 묵시적 반환

- 객체 리터럴 표기법